-- Copyright (c) 2026, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: 0BSD
--
-- | Offer, token funding intent, and principal request in one module to avoid import cycles.
module Loan.LoanOffer where

import DA.Time (addRelTime, days)
import DA.Assert (assertWithinDeadline, (===))
import DA.Optional (fromSome)
import DA.TextMap as TextMap
import Loan.LoanRequest
import Loan.LoanTypes (LoanStatus(Active))
import Loan.CreditProfile
import Loan.Loan
import Licensing.Util as Util (require)
import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 (InstrumentId)
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1

-- | Offer by a lender to fund a loan request. Signatory: lender. Observer: borrower.
--   Not visible to other lenders.
template LoanOffer with
    lender : Party
    borrower : Party
    amount : Decimal
    interestRate : Decimal
    createdAt : Time
    loanRequestId : ContractId LoanRequest
  where
    signatory lender
    observer borrower

    -- | Borrower accepts the offer; consumes LoanRequest and LoanOffer, creates Loan.
    choice LoanOffer_Accept : (ContractId Loan, ContractId CreditProfile)
      with creditProfileId : ContractId CreditProfile
      controller borrower
      do
        request <- fetch loanRequestId
        require "Amount must match request" (request.amount == amount)
        require "Borrower must match" (request.borrower == borrower)
        archive loanRequestId
        now <- getTime
        let dueDate = addRelTime now (days request.durationDays)
        loanCid <- create Loan with
          lender = lender
          borrower = borrower
          principal = amount
          interestRate = interestRate
          dueDate = dueDate
          creditProfileId = creditProfileId
          status = Active
        -- Return updated profile id (caller may exercise RecordSuccessfulLoan later on repay)
        pure (loanCid, creditProfileId)

    -- | Borrower requests token-based funding; creates a FundingIntent for lender confirmation.
    choice LoanOffer_AcceptWithToken : ContractId FundingIntent
      with
        requestId : Text
        principalInstrumentId : InstrumentId
        prepareUntil : Time
        settleBefore : Time
        description : Text
        creditProfileId : ContractId CreditProfile
      controller borrower
      do
        request <- fetch loanRequestId
        require "Amount must match request" (request.amount == amount)
        require "Borrower must match" (request.borrower == borrower)
        now <- getTime
        require "prepareUntil < settleBefore" (prepareUntil < settleBefore)
        require "Preparation time has not passed" (now < prepareUntil)
        create FundingIntent with
          requestId
          lender
          borrower
          principal = amount
          interestRate
          durationDays = request.durationDays
          principalInstrumentId
          prepareUntil
          settleBefore
          requestedAt = now
          description
          loanRequestId
          offerContractId = self
          creditProfileId

-- | Borrower intent to fund a loan using the token standard.
template FundingIntent
  with
    requestId : Text
    lender : Party
    borrower : Party
    principal : Decimal
    interestRate : Decimal
    durationDays : Int
    principalInstrumentId : InstrumentId
    prepareUntil : Time
    settleBefore : Time
    requestedAt : Time
    description : Text
    loanRequestId : ContractId LoanRequest
    offerContractId : ContractId LoanOffer
    creditProfileId : ContractId CreditProfile
  where
    signatory borrower
    observer lender

    postconsuming choice FundingIntent_ConfirmByLender : ContractId LoanPrincipalRequest
      controller lender
      do
        cid <- create LoanPrincipalRequest with
          requestId
          lender
          borrower
          principal
          interestRate
          durationDays
          principalInstrumentId
          prepareUntil
          settleBefore
          requestedAt
          description
          loanRequestId
          offerContractId
          creditProfileId
        pure cid

-- | Token-backed loan funding request (lender -> borrower).
template LoanPrincipalRequest
  with
    requestId : Text
    lender : Party
    borrower : Party
    principal : Decimal
    interestRate : Decimal
    durationDays : Int
    principalInstrumentId : InstrumentId
    prepareUntil : Time
    settleBefore : Time
    requestedAt : Time
    description : Text
    loanRequestId : ContractId LoanRequest
    offerContractId : ContractId LoanOffer
    creditProfileId : ContractId CreditProfile
  where
    signatory lender
    observer borrower

    postconsuming choice LoanPrincipalRequest_CompleteFunding : ContractId Loan
      with
        allocationCid : ContractId Api.Token.AllocationV1.Allocation
        extraArgs : ExtraArgs
      controller lender, borrower
      do
        assertWithinDeadline "settleBefore" settleBefore
        alloc <- fetch @Api.Token.AllocationV1.Allocation allocationCid
        let allocView = view @Api.Token.AllocationV1.Allocation alloc
            thisView = view $ toInterface @AllocationRequest this
            expectedTransferLegId = loanPrincipalLegId
            expectedTransferLeg = fromSome $ TextMap.lookup expectedTransferLegId thisView.transferLegs
        expectedTransferLegId === allocView.allocation.transferLegId
        expectedTransferLeg === allocView.allocation.transferLeg
        thisView.settlement === allocView.allocation.settlement
        exercise allocationCid (Api.Token.AllocationV1.Allocation_ExecuteTransfer extraArgs)
        request <- fetch loanRequestId
        require "Borrower must match" (request.borrower == borrower)
        archive loanRequestId
        now <- getTime
        let dueDate = addRelTime now (days durationDays)
        create Loan with
          lender = lender
          borrower = borrower
          principal = principal
          interestRate = interestRate
          dueDate = dueDate
          creditProfileId = creditProfileId
          status = Active

    interface instance AllocationRequest for LoanPrincipalRequest where
      view =
        let
          meta = Metadata with
            values = TextMap.fromList [
              ("splice.lfdecentralizedtrust.org/reason", description)
              , ("cn-quickstart.example.org/loanPrincipalRequest", requestId)
              ]
        in
          AllocationRequestView
            with
              settlement =
                SettlementInfo
                  with
                    executor = lender
                    requestedAt
                    allocateBefore = prepareUntil
                    settleBefore
                    settlementRef =
                      Reference
                        with
                          id = requestId
                          cid = None
                    meta
              transferLegs = TextMap.fromList
                [(loanPrincipalLegId, Api.Token.AllocationV1.TransferLeg
                    with
                      sender = lender
                      receiver = borrower
                      amount = principal
                      instrumentId = principalInstrumentId
                      meta)
                ]
              meta

      allocationRequest_RejectImpl _ AllocationRequest_Reject{..} = do
        require "Actor is the lender" (actor == lender)
        pure ChoiceExecutionMetadata with meta = emptyMetadata

      allocationRequest_WithdrawImpl _ _ =
        pure ChoiceExecutionMetadata with meta = emptyMetadata

loanPrincipalLegId = "loanPrincipal"
